## **1. Storage Collision in Upgradeable Smart Contracts**

### 1.1 What it is

In upgradeable contracts (especially proxies), **storage layout must be preserved** between implementations. If the new version adds variables in the wrong order or overlaps with proxy storage slots, it leads to **storage collision**, corrupting state and causing unexpected behavior.

### 1.2 Vulnerable Example 

**Proxy.sol**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract Proxy {
    address public implementation; // slot 0

    function upgradeTo(address newImpl) external {
        implementation = newImpl;
    }

    fallback() external payable {
          address impl = implementation;
            assembly {
            //the calldata is copied to memory
            calldatacopy(0, 0, calldatasize())
            //the call is forwarded to the logic contract
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            //the return data from the call to the logic contract is retrieved
            returndatacopy(0, 0, returndatasize())
            //either reverts or forwards the response to the caller.
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
}
```

**V1.sol**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract V1 {
    uint256 public value; // slot 0! 

    function setValue(uint256 _v) public {
        value = _v;
    }
}
```

**Problem:** `V1.value` overlaps with `Proxy.implementation`, since both use slot 0. Setting `value` will overwrite the implementation address.

### 1.3 Fix: Use EIP-1967 Storage Slots; "unstructured storage slots":

Instead of storing the _implementation address at the proxy’s first storage slot, it chooses a pseudo-random slot instead.
This slot is sufficiently random, that the probability of a logic contract declaring a variable at the same slot is negligible. 

For example, storage slot `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` is obtained as `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1))`:
```solidity
bytes32 private constant _IMPLEMENTATION_SLOT = 
    bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1);
```
### 1.4 Real World Hack:
[Audis protocol hack(2022)](https://blog.audius.co/article/audius-governance-takeover-post-mortem-7-23-22)

### 1.5 Read more: 
[EIP 1967](https://eips.ethereum.org/EIPS/eip-1967)

[EIP 7201](https://eips.ethereum.org/EIPS/eip-7201)


## **2. Function Selector Collision**

### 2.1 What is a Function Selector?

In order for a transaction to execute a function on a smart contract, there needs to be a way for a transaction to specify the contract.This is done by a transaction supplying a four-byte value that identifies for a contract what function to execute.

The four-byte value is called a function selector. It consists of the first four bytes of a hash of a string of a function signature. A function signature is a string that consists of a function name and the types of its arguments.

### 2.2 Vulnerability
What if we hold a function in a proxy contract with the same function selector as the implementation/logic contract? It’s only 4 bytes and it is possible. In such a case, which function should get called in the transaction? this becomes exploitable when selectors are used for cross-contract interaction.

### 2.3 Simple vulnerabliity Example

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract SelectorClash {
    function proxyOwner() public {}
    function clash550254402() public {} 
}
```

You can calculate both selectors using:

```python
from eth_utils import keccak

def get_selector(signature: str) -> str:
    return keccak(text=signature)[:4].hex()

print(get_selector("proxyOwner()"))
print(get_selector("clash550254402()"))
```

### 2.4 Fix

Transparent Proxy Pattern solved this problem by using this trick; the proxy contract decides which calls should get forwarded to the implementation contract and which calls should get called in the proxy contract based on the **caller address**.

`ifAdmin() Modifier` - modifier used internally that will delegate the call to the implementation contract unless the sender is the admin: If the caller is any other address, the proxy will always delegate a call, no matter if it matches one of the proxy’s functions.

### 2.5 Read more: 
[Rareskills.io](https://www.rareskills.io/post/function-selector)

## **3. Not Handling ERC20 Return Values**

### 3.1 What It Is

Some ERC20 tokens (e.g., USDT) don’t **revert on failure** — they return `false`. Ignoring this return value means your contract may believe a transfer succeeded when it didn’t.

### 3.2 Vulnerable Code

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
}

contract TokenSend {
    function pay(address token, address to, uint256 amount) external {
        IERC20(token).transfer(to, amount); // Ignoring return value!
    }
}
```

If transfer fails silently (e.g. bad balance), it still continues.

### 3.3 Secure Fix

```solidity
function pay(address token, address to, uint256 amount) external {
    bool success = IERC20(token).transfer(to, amount);
    require(success, "Transfer failed");
}
```

Or use **SafeERC20** from OpenZeppelin:

```solidity
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract SafeTokenSend {
    using SafeERC20 for IERC20;

    function pay(address token, address to, uint256 amount) external {
        IERC20(token).safeTransfer(to, amount); // handles returns and reverts
    }
}
```

### 3.4 Read More:
[OpenZeppelin: SafeERC20 Documentation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol)

## **4. ABI Hash Collision** 
### 4.1 What it is
- Hash Collision in cryptography occurs when two different sets of inputs produce the same hash output using a hash function.
In solidity, before you hash inputs using `keccak256()`, you first encode them using one of the [ABI encoding functions](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#abi-encoding-and-decoding-functions). There are several [ABI](https://docs.soliditylang.org/en/latest/abi-spec.html) encoding and decoding [methods](https://docs.soliditylang.org/en/v0.8.30/units-and-global-variables.html#abi-encoding-and-decoding-functions), with `abi.encodePacked()` being one of them.
- The `abi.encodePacked()` function creates [tightly packed byte](https://docs.soliditylang.org/en/v0.8.30/abi-spec.html#abi-packed-mode) arrays which can then be hashed using `keccak256()`. However, this function can be dangerous when used with **multiple variable-length dynamic type arguments  (such as arrays and strings)** because it can lead to hash collisions due to the lack of boundary information between the arguments.

### 4.2 Vulnerable Code Snippet
```solidity
bytes32 Hash1 = keccak256(abi.encodePacked("some", "where"));
bytes32 Hash2 = keccak256(abi.encodePacked("so", "mew", "here"));
```
> **Note:** Both hashes produces the same packed encoding because `abi.encodePacked()` simply concatenates the elements without any delimiters.
### 4.3 Fix

   -  Avoid using `abi.encodePacked()` with variable-length arguments such as arrays and strings. Instead, use fixed-length arrays to ensure the encoding is unique and unambiguous.

   - Use `abi.encode()` Instead: Unlike `abi.encodePacked()`, `abi.encode()` includes additional type information and length prefixes in the encoding, making it much less prone to hash collisions.
### 4.4 Real-World Hack
- [Poly Network](https://rekt.news/polynetwork-rekt)
### 4.5 Learn More
 * [Kaden's Medium blog](https://medium.com/@0xkaden/new-smart-contract-weakness-hash-collisions-with-multiple-variable-length-arguments-dc7b9c84e493)
 * [Kaden's Repo on Hash Collision](https://github.com/kadenzipfel/smart-contract-vulnerabilities/blob/master/vulnerabilities/hash-collision.md)
 * [Smart Contract Weakness Classification #133](https://swcregistry.io/docs/SWC-133/)
 * [Solidity Non-standard Packed Mode](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode)

## **5. Issues in Low-level calls**
### 5.1 What it is
- In Solidity, [Low level calls](https://docs.soliditylang.org/en/v0.8.23/units-and-global-variables.html#members-of-address-types) are functions provided by the `address` type that allow you to directly invoke functions on other contracts or send Ether. Examples are: `address.call()`,  `address.delegatecall()`, `address.send()` e.t.c 
- [Solidity docs](https://docs.soliditylang.org/en/v0.8.15/control-structures.html?highlight=low%20level%20calls#external-function-calls) states that: "Due to the fact that the EVM considers a call to a non-existing contract to always succeed, Solidity uses the [`extcodesize`](https://www.evm.codes/?fork=cancun#3b) opcode to check that the contract that is about to be called actually exists (it contains code) and causes an exception if it does not. This check is skipped if the return data will be decoded after the call and thus the ABI decoder will catch the case of a non-existing contract.

Note that this check is not performed in case of low-level calls which operate on addresses rather than contract instances."
### 5.2 Vulnerable Code Example
```solidity
function sendEth(address payable recipientContract) public {
(bool success,) = recipientContract.call{value: 1 ether}(""); 
require(success, "ETH transfer failed");
}
```
### 5.3 Fix
```solidity
function sendEth(address payable recipientContract) public {
// Verify address is a contract
require(to.code.length > 0);
(bool success,) = recipientContract.call{value: 1 ether}(""); 
require(success, "ETH transfer failed");
}
```
### 5.4 Learn More
- [Solidity docs](https://docs.soliditylang.org/en/v0.8.15/control-structures.html?highlight=low%20level%20calls#external-function-calls)

## **6. Overflow and Underflow in signed and unsigned types.**
### 6.1 What it is
- Integer overflow occurs when an integer variable exceeds the maximum value that can be stored in that variable type. Similarly, Integer underflow occurs when an integer variable goes below the minimum value for that variable type. 
- This was an issue in solidity versions prior [0.8](https://docs.soliditylang.org/en/latest/080-breaking-changes.html#silent-changes-of-the-semantics) but even after the update of solidity to [0.8](https://docs.soliditylang.org/en/latest/080-breaking-changes.html#silent-changes-of-the-semantics), overflow and underflow can still occur in scenarios such as typecasting. 
### 6.2 Vulnerable Code Example
```solidity
function mul( uint8 a, uint8 b) public view returns(uint256){
 uint256 c = a * b;
 return c;
 }
```
### 6.3 Fix  
```solidity
function mul( uint8 a, uint8 b) public view returns(uint256){
 uint256 c = uint256(a) * b;
 return c;
 }
```
### 6.4 Learn More
- [How Solidity 0.8 protect against integer underflow/overflow and how they can still happen in Solidity 0.8](https://faizannehal.medium.com/how-solidity-0-8-protect-against-integer-underflow-overflow-and-how-they-can-still-happen-7be22c4ab92f)
